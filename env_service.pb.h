// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: env_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_env_5fservice_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_env_5fservice_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_env_5fservice_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_env_5fservice_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_env_5fservice_2eproto;
namespace environmentdata {
class Area;
struct AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class Crater;
struct CraterDefaultTypeInternal;
extern CraterDefaultTypeInternal _Crater_default_instance_;
class CraterArea;
struct CraterAreaDefaultTypeInternal;
extern CraterAreaDefaultTypeInternal _CraterArea_default_instance_;
class GetDataRequest;
struct GetDataRequestDefaultTypeInternal;
extern GetDataRequestDefaultTypeInternal _GetDataRequest_default_instance_;
class GetDataResponse;
struct GetDataResponseDefaultTypeInternal;
extern GetDataResponseDefaultTypeInternal _GetDataResponse_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class RoutePoints;
struct RoutePointsDefaultTypeInternal;
extern RoutePointsDefaultTypeInternal _RoutePoints_default_instance_;
class StartStopPoints;
struct StartStopPointsDefaultTypeInternal;
extern StartStopPointsDefaultTypeInternal _StartStopPoints_default_instance_;
}  // namespace environmentdata
PROTOBUF_NAMESPACE_OPEN
template <>
::environmentdata::Area* Arena::CreateMaybeMessage<::environmentdata::Area>(Arena*);
template <>
::environmentdata::Crater* Arena::CreateMaybeMessage<::environmentdata::Crater>(Arena*);
template <>
::environmentdata::CraterArea* Arena::CreateMaybeMessage<::environmentdata::CraterArea>(Arena*);
template <>
::environmentdata::GetDataRequest* Arena::CreateMaybeMessage<::environmentdata::GetDataRequest>(Arena*);
template <>
::environmentdata::GetDataResponse* Arena::CreateMaybeMessage<::environmentdata::GetDataResponse>(Arena*);
template <>
::environmentdata::Position* Arena::CreateMaybeMessage<::environmentdata::Position>(Arena*);
template <>
::environmentdata::RoutePoints* Arena::CreateMaybeMessage<::environmentdata::RoutePoints>(Arena*);
template <>
::environmentdata::StartStopPoints* Arena::CreateMaybeMessage<::environmentdata::StartStopPoints>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace environmentdata {
enum DataType : int {
  ZERO = 0,
  DEM = 1,
  PBF = 2,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = static_cast<DataType>(0);
constexpr DataType DataType_MAX = static_cast<DataType>(2);
constexpr int DataType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DataType_descriptor();
template <typename T>
const std::string& DataType_Name(T value) {
  static_assert(std::is_same<T, DataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataType_Name().");
  return DataType_Name(static_cast<DataType>(value));
}
template <>
inline const std::string& DataType_Name(DataType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DataType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DataType_Parse(absl::string_view name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
      DataType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class CraterArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.CraterArea) */ {
 public:
  inline CraterArea() : CraterArea(nullptr) {}
  ~CraterArea() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CraterArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CraterArea(const CraterArea& from);
  CraterArea(CraterArea&& from) noexcept
    : CraterArea() {
    *this = ::std::move(from);
  }

  inline CraterArea& operator=(const CraterArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline CraterArea& operator=(CraterArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CraterArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const CraterArea* internal_default_instance() {
    return reinterpret_cast<const CraterArea*>(
               &_CraterArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CraterArea& a, CraterArea& b) {
    a.Swap(&b);
  }
  inline void Swap(CraterArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CraterArea* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CraterArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CraterArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CraterArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CraterArea& from) {
    CraterArea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CraterArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.CraterArea";
  }
  protected:
  explicit CraterArea(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTileIDFieldNumber = 1,
  };
  // string tileID = 1;
  void clear_tileid() ;
  const std::string& tileid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tileid(Arg_&& arg, Args_... args);
  std::string* mutable_tileid();
  PROTOBUF_NODISCARD std::string* release_tileid();
  void set_allocated_tileid(std::string* ptr);

  private:
  const std::string& _internal_tileid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tileid(
      const std::string& value);
  std::string* _internal_mutable_tileid();

  public:
  // @@protoc_insertion_point(class_scope:environmentdata.CraterArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tileid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
  };
  // double longitude = 1;
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // double latitude = 2;
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // @@protoc_insertion_point(class_scope:environmentdata.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double longitude_;
    double latitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class Area final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.Area) */ {
 public:
  inline Area() : Area(nullptr) {}
  ~Area() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Area(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Area(const Area& from);
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  inline Area& operator=(Area&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Area& default_instance() {
    return *internal_default_instance();
  }
  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }
  inline void Swap(Area* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Area* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Area* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Area>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Area& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Area& from) {
    Area::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Area* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.Area";
  }
  protected:
  explicit Area(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBottomleftFieldNumber = 1,
    kToprightFieldNumber = 2,
  };
  // .environmentdata.Position bottomleft = 1;
  bool has_bottomleft() const;
  void clear_bottomleft() ;
  const ::environmentdata::Position& bottomleft() const;
  PROTOBUF_NODISCARD ::environmentdata::Position* release_bottomleft();
  ::environmentdata::Position* mutable_bottomleft();
  void set_allocated_bottomleft(::environmentdata::Position* bottomleft);
  private:
  const ::environmentdata::Position& _internal_bottomleft() const;
  ::environmentdata::Position* _internal_mutable_bottomleft();
  public:
  void unsafe_arena_set_allocated_bottomleft(
      ::environmentdata::Position* bottomleft);
  ::environmentdata::Position* unsafe_arena_release_bottomleft();
  // .environmentdata.Position topright = 2;
  bool has_topright() const;
  void clear_topright() ;
  const ::environmentdata::Position& topright() const;
  PROTOBUF_NODISCARD ::environmentdata::Position* release_topright();
  ::environmentdata::Position* mutable_topright();
  void set_allocated_topright(::environmentdata::Position* topright);
  private:
  const ::environmentdata::Position& _internal_topright() const;
  ::environmentdata::Position* _internal_mutable_topright();
  public:
  void unsafe_arena_set_allocated_topright(
      ::environmentdata::Position* topright);
  ::environmentdata::Position* unsafe_arena_release_topright();
  // @@protoc_insertion_point(class_scope:environmentdata.Area)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::environmentdata::Position* bottomleft_;
    ::environmentdata::Position* topright_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class Crater final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.Crater) */ {
 public:
  inline Crater() : Crater(nullptr) {}
  ~Crater() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Crater(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Crater(const Crater& from);
  Crater(Crater&& from) noexcept
    : Crater() {
    *this = ::std::move(from);
  }

  inline Crater& operator=(const Crater& from) {
    CopyFrom(from);
    return *this;
  }
  inline Crater& operator=(Crater&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Crater& default_instance() {
    return *internal_default_instance();
  }
  static inline const Crater* internal_default_instance() {
    return reinterpret_cast<const Crater*>(
               &_Crater_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Crater& a, Crater& b) {
    a.Swap(&b);
  }
  inline void Swap(Crater* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Crater* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Crater* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Crater>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Crater& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Crater& from) {
    Crater::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Crater* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.Crater";
  }
  protected:
  explicit Crater(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 3,
    kWidthFieldNumber = 1,
    kDepthFieldNumber = 2,
  };
  // .environmentdata.Position pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::environmentdata::Position& pos() const;
  PROTOBUF_NODISCARD ::environmentdata::Position* release_pos();
  ::environmentdata::Position* mutable_pos();
  void set_allocated_pos(::environmentdata::Position* pos);
  private:
  const ::environmentdata::Position& _internal_pos() const;
  ::environmentdata::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::environmentdata::Position* pos);
  ::environmentdata::Position* unsafe_arena_release_pos();
  // double width = 1;
  void clear_width() ;
  double width() const;
  void set_width(double value);

  private:
  double _internal_width() const;
  void _internal_set_width(double value);

  public:
  // double depth = 2;
  void clear_depth() ;
  double depth() const;
  void set_depth(double value);

  private:
  double _internal_depth() const;
  void _internal_set_depth(double value);

  public:
  // @@protoc_insertion_point(class_scope:environmentdata.Crater)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::environmentdata::Position* pos_;
    double width_;
    double depth_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class GetDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.GetDataRequest) */ {
 public:
  inline GetDataRequest() : GetDataRequest(nullptr) {}
  ~GetDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataRequest(const GetDataRequest& from);
  GetDataRequest(GetDataRequest&& from) noexcept
    : GetDataRequest() {
    *this = ::std::move(from);
  }

  inline GetDataRequest& operator=(const GetDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataRequest& operator=(GetDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetDataRequest*>(
               &_GetDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetDataRequest& a, GetDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataRequest& from) {
    GetDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.GetDataRequest";
  }
  protected:
  explicit GetDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 2,
    kAreaFieldNumber = 1,
    kLevelFieldNumber = 3,
    kDataTypeFieldNumber = 4,
  };
  // string time = 2;
  void clear_time() ;
  const std::string& time() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time(Arg_&& arg, Args_... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* ptr);

  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(
      const std::string& value);
  std::string* _internal_mutable_time();

  public:
  // .environmentdata.Area area = 1;
  bool has_area() const;
  void clear_area() ;
  const ::environmentdata::Area& area() const;
  PROTOBUF_NODISCARD ::environmentdata::Area* release_area();
  ::environmentdata::Area* mutable_area();
  void set_allocated_area(::environmentdata::Area* area);
  private:
  const ::environmentdata::Area& _internal_area() const;
  ::environmentdata::Area* _internal_mutable_area();
  public:
  void unsafe_arena_set_allocated_area(
      ::environmentdata::Area* area);
  ::environmentdata::Area* unsafe_arena_release_area();
  // int32 level = 3;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // .environmentdata.DataType dataType = 4;
  void clear_datatype() ;
  ::environmentdata::DataType datatype() const;
  void set_datatype(::environmentdata::DataType value);

  private:
  ::environmentdata::DataType _internal_datatype() const;
  void _internal_set_datatype(::environmentdata::DataType value);

  public:
  // @@protoc_insertion_point(class_scope:environmentdata.GetDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::environmentdata::Area* area_;
    ::int32_t level_;
    int datatype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class GetDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.GetDataResponse) */ {
 public:
  inline GetDataResponse() : GetDataResponse(nullptr) {}
  ~GetDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDataResponse(const GetDataResponse& from);
  GetDataResponse(GetDataResponse&& from) noexcept
    : GetDataResponse() {
    *this = ::std::move(from);
  }

  inline GetDataResponse& operator=(const GetDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDataResponse& operator=(GetDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetDataResponse*>(
               &_GetDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetDataResponse& a, GetDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDataResponse& from) {
    GetDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.GetDataResponse";
  }
  protected:
  explicit GetDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCratersFieldNumber = 3,
    kTileIDFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // repeated .environmentdata.Crater craters = 3;
  int craters_size() const;
  private:
  int _internal_craters_size() const;

  public:
  void clear_craters() ;
  ::environmentdata::Crater* mutable_craters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Crater >*
      mutable_craters();
  private:
  const ::environmentdata::Crater& _internal_craters(int index) const;
  ::environmentdata::Crater* _internal_add_craters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Crater>& _internal_craters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Crater>* _internal_mutable_craters();
  public:
  const ::environmentdata::Crater& craters(int index) const;
  ::environmentdata::Crater* add_craters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Crater >&
      craters() const;
  // string tileID = 1;
  void clear_tileid() ;
  const std::string& tileid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tileid(Arg_&& arg, Args_... args);
  std::string* mutable_tileid();
  PROTOBUF_NODISCARD std::string* release_tileid();
  void set_allocated_tileid(std::string* ptr);

  private:
  const std::string& _internal_tileid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tileid(
      const std::string& value);
  std::string* _internal_mutable_tileid();

  public:
  // bytes content = 2;
  void clear_content() ;
  const std::string& content() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // @@protoc_insertion_point(class_scope:environmentdata.GetDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Crater > craters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tileid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class StartStopPoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.StartStopPoints) */ {
 public:
  inline StartStopPoints() : StartStopPoints(nullptr) {}
  ~StartStopPoints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartStopPoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartStopPoints(const StartStopPoints& from);
  StartStopPoints(StartStopPoints&& from) noexcept
    : StartStopPoints() {
    *this = ::std::move(from);
  }

  inline StartStopPoints& operator=(const StartStopPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartStopPoints& operator=(StartStopPoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartStopPoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartStopPoints* internal_default_instance() {
    return reinterpret_cast<const StartStopPoints*>(
               &_StartStopPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StartStopPoints& a, StartStopPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(StartStopPoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartStopPoints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartStopPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartStopPoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartStopPoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartStopPoints& from) {
    StartStopPoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartStopPoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.StartStopPoints";
  }
  protected:
  explicit StartStopPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .environmentdata.Position start = 1;
  bool has_start() const;
  void clear_start() ;
  const ::environmentdata::Position& start() const;
  PROTOBUF_NODISCARD ::environmentdata::Position* release_start();
  ::environmentdata::Position* mutable_start();
  void set_allocated_start(::environmentdata::Position* start);
  private:
  const ::environmentdata::Position& _internal_start() const;
  ::environmentdata::Position* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::environmentdata::Position* start);
  ::environmentdata::Position* unsafe_arena_release_start();
  // .environmentdata.Position end = 2;
  bool has_end() const;
  void clear_end() ;
  const ::environmentdata::Position& end() const;
  PROTOBUF_NODISCARD ::environmentdata::Position* release_end();
  ::environmentdata::Position* mutable_end();
  void set_allocated_end(::environmentdata::Position* end);
  private:
  const ::environmentdata::Position& _internal_end() const;
  ::environmentdata::Position* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::environmentdata::Position* end);
  ::environmentdata::Position* unsafe_arena_release_end();
  // @@protoc_insertion_point(class_scope:environmentdata.StartStopPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::environmentdata::Position* start_;
    ::environmentdata::Position* end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};// -------------------------------------------------------------------

class RoutePoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environmentdata.RoutePoints) */ {
 public:
  inline RoutePoints() : RoutePoints(nullptr) {}
  ~RoutePoints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoutePoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutePoints(const RoutePoints& from);
  RoutePoints(RoutePoints&& from) noexcept
    : RoutePoints() {
    *this = ::std::move(from);
  }

  inline RoutePoints& operator=(const RoutePoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutePoints& operator=(RoutePoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutePoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutePoints* internal_default_instance() {
    return reinterpret_cast<const RoutePoints*>(
               &_RoutePoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoutePoints& a, RoutePoints& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutePoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutePoints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutePoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoutePoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutePoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoutePoints& from) {
    RoutePoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutePoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "environmentdata.RoutePoints";
  }
  protected:
  explicit RoutePoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
  };
  // repeated .environmentdata.Position pos = 1;
  int pos_size() const;
  private:
  int _internal_pos_size() const;

  public:
  void clear_pos() ;
  ::environmentdata::Position* mutable_pos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Position >*
      mutable_pos();
  private:
  const ::environmentdata::Position& _internal_pos(int index) const;
  ::environmentdata::Position* _internal_add_pos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Position>& _internal_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Position>* _internal_mutable_pos();
  public:
  const ::environmentdata::Position& pos(int index) const;
  ::environmentdata::Position* add_pos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Position >&
      pos() const;
  // @@protoc_insertion_point(class_scope:environmentdata.RoutePoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Position > pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_env_5fservice_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CraterArea

// string tileID = 1;
inline void CraterArea::clear_tileid() {
  _impl_.tileid_.ClearToEmpty();
}
inline const std::string& CraterArea::tileid() const {
  // @@protoc_insertion_point(field_get:environmentdata.CraterArea.tileID)
  return _internal_tileid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CraterArea::set_tileid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tileid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:environmentdata.CraterArea.tileID)
}
inline std::string* CraterArea::mutable_tileid() {
  std::string* _s = _internal_mutable_tileid();
  // @@protoc_insertion_point(field_mutable:environmentdata.CraterArea.tileID)
  return _s;
}
inline const std::string& CraterArea::_internal_tileid() const {
  return _impl_.tileid_.Get();
}
inline void CraterArea::_internal_set_tileid(const std::string& value) {
  ;


  _impl_.tileid_.Set(value, GetArenaForAllocation());
}
inline std::string* CraterArea::_internal_mutable_tileid() {
  ;
  return _impl_.tileid_.Mutable( GetArenaForAllocation());
}
inline std::string* CraterArea::release_tileid() {
  // @@protoc_insertion_point(field_release:environmentdata.CraterArea.tileID)
  return _impl_.tileid_.Release();
}
inline void CraterArea::set_allocated_tileid(std::string* value) {
  _impl_.tileid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tileid_.IsDefault()) {
          _impl_.tileid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:environmentdata.CraterArea.tileID)
}

// -------------------------------------------------------------------

// Position

// double longitude = 1;
inline void Position::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline double Position::longitude() const {
  // @@protoc_insertion_point(field_get:environmentdata.Position.longitude)
  return _internal_longitude();
}
inline void Position::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:environmentdata.Position.longitude)
}
inline double Position::_internal_longitude() const {
  return _impl_.longitude_;
}
inline void Position::_internal_set_longitude(double value) {
  ;
  _impl_.longitude_ = value;
}

// double latitude = 2;
inline void Position::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline double Position::latitude() const {
  // @@protoc_insertion_point(field_get:environmentdata.Position.latitude)
  return _internal_latitude();
}
inline void Position::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:environmentdata.Position.latitude)
}
inline double Position::_internal_latitude() const {
  return _impl_.latitude_;
}
inline void Position::_internal_set_latitude(double value) {
  ;
  _impl_.latitude_ = value;
}

// -------------------------------------------------------------------

// Area

// .environmentdata.Position bottomleft = 1;
inline bool Area::has_bottomleft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bottomleft_ != nullptr);
  return value;
}
inline void Area::clear_bottomleft() {
  if (_impl_.bottomleft_ != nullptr) _impl_.bottomleft_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::environmentdata::Position& Area::_internal_bottomleft() const {
  const ::environmentdata::Position* p = _impl_.bottomleft_;
  return p != nullptr ? *p : reinterpret_cast<const ::environmentdata::Position&>(
      ::environmentdata::_Position_default_instance_);
}
inline const ::environmentdata::Position& Area::bottomleft() const {
  // @@protoc_insertion_point(field_get:environmentdata.Area.bottomleft)
  return _internal_bottomleft();
}
inline void Area::unsafe_arena_set_allocated_bottomleft(
    ::environmentdata::Position* bottomleft) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bottomleft_);
  }
  _impl_.bottomleft_ = bottomleft;
  if (bottomleft) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:environmentdata.Area.bottomleft)
}
inline ::environmentdata::Position* Area::release_bottomleft() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Position* temp = _impl_.bottomleft_;
  _impl_.bottomleft_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::environmentdata::Position* Area::unsafe_arena_release_bottomleft() {
  // @@protoc_insertion_point(field_release:environmentdata.Area.bottomleft)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Position* temp = _impl_.bottomleft_;
  _impl_.bottomleft_ = nullptr;
  return temp;
}
inline ::environmentdata::Position* Area::_internal_mutable_bottomleft() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bottomleft_ == nullptr) {
    auto* p = CreateMaybeMessage<::environmentdata::Position>(GetArenaForAllocation());
    _impl_.bottomleft_ = p;
  }
  return _impl_.bottomleft_;
}
inline ::environmentdata::Position* Area::mutable_bottomleft() {
  ::environmentdata::Position* _msg = _internal_mutable_bottomleft();
  // @@protoc_insertion_point(field_mutable:environmentdata.Area.bottomleft)
  return _msg;
}
inline void Area::set_allocated_bottomleft(::environmentdata::Position* bottomleft) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bottomleft_;
  }
  if (bottomleft) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bottomleft);
    if (message_arena != submessage_arena) {
      bottomleft = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottomleft, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bottomleft_ = bottomleft;
  // @@protoc_insertion_point(field_set_allocated:environmentdata.Area.bottomleft)
}

// .environmentdata.Position topright = 2;
inline bool Area::has_topright() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.topright_ != nullptr);
  return value;
}
inline void Area::clear_topright() {
  if (_impl_.topright_ != nullptr) _impl_.topright_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::environmentdata::Position& Area::_internal_topright() const {
  const ::environmentdata::Position* p = _impl_.topright_;
  return p != nullptr ? *p : reinterpret_cast<const ::environmentdata::Position&>(
      ::environmentdata::_Position_default_instance_);
}
inline const ::environmentdata::Position& Area::topright() const {
  // @@protoc_insertion_point(field_get:environmentdata.Area.topright)
  return _internal_topright();
}
inline void Area::unsafe_arena_set_allocated_topright(
    ::environmentdata::Position* topright) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topright_);
  }
  _impl_.topright_ = topright;
  if (topright) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:environmentdata.Area.topright)
}
inline ::environmentdata::Position* Area::release_topright() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::environmentdata::Position* temp = _impl_.topright_;
  _impl_.topright_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::environmentdata::Position* Area::unsafe_arena_release_topright() {
  // @@protoc_insertion_point(field_release:environmentdata.Area.topright)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::environmentdata::Position* temp = _impl_.topright_;
  _impl_.topright_ = nullptr;
  return temp;
}
inline ::environmentdata::Position* Area::_internal_mutable_topright() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.topright_ == nullptr) {
    auto* p = CreateMaybeMessage<::environmentdata::Position>(GetArenaForAllocation());
    _impl_.topright_ = p;
  }
  return _impl_.topright_;
}
inline ::environmentdata::Position* Area::mutable_topright() {
  ::environmentdata::Position* _msg = _internal_mutable_topright();
  // @@protoc_insertion_point(field_mutable:environmentdata.Area.topright)
  return _msg;
}
inline void Area::set_allocated_topright(::environmentdata::Position* topright) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.topright_;
  }
  if (topright) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(topright);
    if (message_arena != submessage_arena) {
      topright = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topright, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.topright_ = topright;
  // @@protoc_insertion_point(field_set_allocated:environmentdata.Area.topright)
}

// -------------------------------------------------------------------

// Crater

// double width = 1;
inline void Crater::clear_width() {
  _impl_.width_ = 0;
}
inline double Crater::width() const {
  // @@protoc_insertion_point(field_get:environmentdata.Crater.width)
  return _internal_width();
}
inline void Crater::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:environmentdata.Crater.width)
}
inline double Crater::_internal_width() const {
  return _impl_.width_;
}
inline void Crater::_internal_set_width(double value) {
  ;
  _impl_.width_ = value;
}

// double depth = 2;
inline void Crater::clear_depth() {
  _impl_.depth_ = 0;
}
inline double Crater::depth() const {
  // @@protoc_insertion_point(field_get:environmentdata.Crater.depth)
  return _internal_depth();
}
inline void Crater::set_depth(double value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:environmentdata.Crater.depth)
}
inline double Crater::_internal_depth() const {
  return _impl_.depth_;
}
inline void Crater::_internal_set_depth(double value) {
  ;
  _impl_.depth_ = value;
}

// .environmentdata.Position pos = 3;
inline bool Crater::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void Crater::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::environmentdata::Position& Crater::_internal_pos() const {
  const ::environmentdata::Position* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::environmentdata::Position&>(
      ::environmentdata::_Position_default_instance_);
}
inline const ::environmentdata::Position& Crater::pos() const {
  // @@protoc_insertion_point(field_get:environmentdata.Crater.pos)
  return _internal_pos();
}
inline void Crater::unsafe_arena_set_allocated_pos(
    ::environmentdata::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:environmentdata.Crater.pos)
}
inline ::environmentdata::Position* Crater::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::environmentdata::Position* Crater::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:environmentdata.Crater.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::environmentdata::Position* Crater::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::environmentdata::Position>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::environmentdata::Position* Crater::mutable_pos() {
  ::environmentdata::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:environmentdata.Crater.pos)
  return _msg;
}
inline void Crater::set_allocated_pos(::environmentdata::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:environmentdata.Crater.pos)
}

// -------------------------------------------------------------------

// GetDataRequest

// .environmentdata.Area area = 1;
inline bool GetDataRequest::has_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.area_ != nullptr);
  return value;
}
inline void GetDataRequest::clear_area() {
  if (_impl_.area_ != nullptr) _impl_.area_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::environmentdata::Area& GetDataRequest::_internal_area() const {
  const ::environmentdata::Area* p = _impl_.area_;
  return p != nullptr ? *p : reinterpret_cast<const ::environmentdata::Area&>(
      ::environmentdata::_Area_default_instance_);
}
inline const ::environmentdata::Area& GetDataRequest::area() const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataRequest.area)
  return _internal_area();
}
inline void GetDataRequest::unsafe_arena_set_allocated_area(
    ::environmentdata::Area* area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_);
  }
  _impl_.area_ = area;
  if (area) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:environmentdata.GetDataRequest.area)
}
inline ::environmentdata::Area* GetDataRequest::release_area() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Area* temp = _impl_.area_;
  _impl_.area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::environmentdata::Area* GetDataRequest::unsafe_arena_release_area() {
  // @@protoc_insertion_point(field_release:environmentdata.GetDataRequest.area)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Area* temp = _impl_.area_;
  _impl_.area_ = nullptr;
  return temp;
}
inline ::environmentdata::Area* GetDataRequest::_internal_mutable_area() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.area_ == nullptr) {
    auto* p = CreateMaybeMessage<::environmentdata::Area>(GetArenaForAllocation());
    _impl_.area_ = p;
  }
  return _impl_.area_;
}
inline ::environmentdata::Area* GetDataRequest::mutable_area() {
  ::environmentdata::Area* _msg = _internal_mutable_area();
  // @@protoc_insertion_point(field_mutable:environmentdata.GetDataRequest.area)
  return _msg;
}
inline void GetDataRequest::set_allocated_area(::environmentdata::Area* area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_;
  }
  if (area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area);
    if (message_arena != submessage_arena) {
      area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.area_ = area;
  // @@protoc_insertion_point(field_set_allocated:environmentdata.GetDataRequest.area)
}

// string time = 2;
inline void GetDataRequest::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& GetDataRequest::time() const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataRequest.time)
  return _internal_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataRequest::set_time(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.time_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:environmentdata.GetDataRequest.time)
}
inline std::string* GetDataRequest::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:environmentdata.GetDataRequest.time)
  return _s;
}
inline const std::string& GetDataRequest::_internal_time() const {
  return _impl_.time_.Get();
}
inline void GetDataRequest::_internal_set_time(const std::string& value) {
  ;


  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataRequest::_internal_mutable_time() {
  ;
  return _impl_.time_.Mutable( GetArenaForAllocation());
}
inline std::string* GetDataRequest::release_time() {
  // @@protoc_insertion_point(field_release:environmentdata.GetDataRequest.time)
  return _impl_.time_.Release();
}
inline void GetDataRequest::set_allocated_time(std::string* value) {
  _impl_.time_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.time_.IsDefault()) {
          _impl_.time_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:environmentdata.GetDataRequest.time)
}

// int32 level = 3;
inline void GetDataRequest::clear_level() {
  _impl_.level_ = 0;
}
inline ::int32_t GetDataRequest::level() const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataRequest.level)
  return _internal_level();
}
inline void GetDataRequest::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:environmentdata.GetDataRequest.level)
}
inline ::int32_t GetDataRequest::_internal_level() const {
  return _impl_.level_;
}
inline void GetDataRequest::_internal_set_level(::int32_t value) {
  ;
  _impl_.level_ = value;
}

// .environmentdata.DataType dataType = 4;
inline void GetDataRequest::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::environmentdata::DataType GetDataRequest::datatype() const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataRequest.dataType)
  return _internal_datatype();
}
inline void GetDataRequest::set_datatype(::environmentdata::DataType value) {
   _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:environmentdata.GetDataRequest.dataType)
}
inline ::environmentdata::DataType GetDataRequest::_internal_datatype() const {
  return static_cast<::environmentdata::DataType>(_impl_.datatype_);
}
inline void GetDataRequest::_internal_set_datatype(::environmentdata::DataType value) {
  ;
  _impl_.datatype_ = value;
}

// -------------------------------------------------------------------

// GetDataResponse

// string tileID = 1;
inline void GetDataResponse::clear_tileid() {
  _impl_.tileid_.ClearToEmpty();
}
inline const std::string& GetDataResponse::tileid() const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataResponse.tileID)
  return _internal_tileid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataResponse::set_tileid(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tileid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:environmentdata.GetDataResponse.tileID)
}
inline std::string* GetDataResponse::mutable_tileid() {
  std::string* _s = _internal_mutable_tileid();
  // @@protoc_insertion_point(field_mutable:environmentdata.GetDataResponse.tileID)
  return _s;
}
inline const std::string& GetDataResponse::_internal_tileid() const {
  return _impl_.tileid_.Get();
}
inline void GetDataResponse::_internal_set_tileid(const std::string& value) {
  ;


  _impl_.tileid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataResponse::_internal_mutable_tileid() {
  ;
  return _impl_.tileid_.Mutable( GetArenaForAllocation());
}
inline std::string* GetDataResponse::release_tileid() {
  // @@protoc_insertion_point(field_release:environmentdata.GetDataResponse.tileID)
  return _impl_.tileid_.Release();
}
inline void GetDataResponse::set_allocated_tileid(std::string* value) {
  _impl_.tileid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tileid_.IsDefault()) {
          _impl_.tileid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:environmentdata.GetDataResponse.tileID)
}

// bytes content = 2;
inline void GetDataResponse::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& GetDataResponse::content() const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataResponse.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetDataResponse::set_content(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:environmentdata.GetDataResponse.content)
}
inline std::string* GetDataResponse::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:environmentdata.GetDataResponse.content)
  return _s;
}
inline const std::string& GetDataResponse::_internal_content() const {
  return _impl_.content_.Get();
}
inline void GetDataResponse::_internal_set_content(const std::string& value) {
  ;


  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDataResponse::_internal_mutable_content() {
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* GetDataResponse::release_content() {
  // @@protoc_insertion_point(field_release:environmentdata.GetDataResponse.content)
  return _impl_.content_.Release();
}
inline void GetDataResponse::set_allocated_content(std::string* value) {
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:environmentdata.GetDataResponse.content)
}

// repeated .environmentdata.Crater craters = 3;
inline int GetDataResponse::_internal_craters_size() const {
  return _impl_.craters_.size();
}
inline int GetDataResponse::craters_size() const {
  return _internal_craters_size();
}
inline void GetDataResponse::clear_craters() {
  _internal_mutable_craters()->Clear();
}
inline ::environmentdata::Crater* GetDataResponse::mutable_craters(int index) {
  // @@protoc_insertion_point(field_mutable:environmentdata.GetDataResponse.craters)
  return _internal_mutable_craters()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Crater >*
GetDataResponse::mutable_craters() {
  // @@protoc_insertion_point(field_mutable_list:environmentdata.GetDataResponse.craters)
  return _internal_mutable_craters();
}
inline const ::environmentdata::Crater& GetDataResponse::_internal_craters(int index) const {
  return _internal_craters().Get(index);
}
inline const ::environmentdata::Crater& GetDataResponse::craters(int index) const {
  // @@protoc_insertion_point(field_get:environmentdata.GetDataResponse.craters)
  return _internal_craters(index);
}
inline ::environmentdata::Crater* GetDataResponse::_internal_add_craters() {
  return _internal_mutable_craters()->Add();
}
inline ::environmentdata::Crater* GetDataResponse::add_craters() {
  ::environmentdata::Crater* _add = _internal_add_craters();
  // @@protoc_insertion_point(field_add:environmentdata.GetDataResponse.craters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Crater >&
GetDataResponse::craters() const {
  // @@protoc_insertion_point(field_list:environmentdata.GetDataResponse.craters)
  return _internal_craters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Crater>&
GetDataResponse::_internal_craters() const {
  return _impl_.craters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Crater>*
GetDataResponse::_internal_mutable_craters() {
  return &_impl_.craters_;
}

// -------------------------------------------------------------------

// StartStopPoints

// .environmentdata.Position start = 1;
inline bool StartStopPoints::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void StartStopPoints::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::environmentdata::Position& StartStopPoints::_internal_start() const {
  const ::environmentdata::Position* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::environmentdata::Position&>(
      ::environmentdata::_Position_default_instance_);
}
inline const ::environmentdata::Position& StartStopPoints::start() const {
  // @@protoc_insertion_point(field_get:environmentdata.StartStopPoints.start)
  return _internal_start();
}
inline void StartStopPoints::unsafe_arena_set_allocated_start(
    ::environmentdata::Position* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:environmentdata.StartStopPoints.start)
}
inline ::environmentdata::Position* StartStopPoints::release_start() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Position* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::environmentdata::Position* StartStopPoints::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:environmentdata.StartStopPoints.start)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::environmentdata::Position* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::environmentdata::Position* StartStopPoints::_internal_mutable_start() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::environmentdata::Position>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::environmentdata::Position* StartStopPoints::mutable_start() {
  ::environmentdata::Position* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:environmentdata.StartStopPoints.start)
  return _msg;
}
inline void StartStopPoints::set_allocated_start(::environmentdata::Position* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:environmentdata.StartStopPoints.start)
}

// .environmentdata.Position end = 2;
inline bool StartStopPoints::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void StartStopPoints::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::environmentdata::Position& StartStopPoints::_internal_end() const {
  const ::environmentdata::Position* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::environmentdata::Position&>(
      ::environmentdata::_Position_default_instance_);
}
inline const ::environmentdata::Position& StartStopPoints::end() const {
  // @@protoc_insertion_point(field_get:environmentdata.StartStopPoints.end)
  return _internal_end();
}
inline void StartStopPoints::unsafe_arena_set_allocated_end(
    ::environmentdata::Position* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:environmentdata.StartStopPoints.end)
}
inline ::environmentdata::Position* StartStopPoints::release_end() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::environmentdata::Position* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::environmentdata::Position* StartStopPoints::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:environmentdata.StartStopPoints.end)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::environmentdata::Position* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::environmentdata::Position* StartStopPoints::_internal_mutable_end() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::environmentdata::Position>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::environmentdata::Position* StartStopPoints::mutable_end() {
  ::environmentdata::Position* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:environmentdata.StartStopPoints.end)
  return _msg;
}
inline void StartStopPoints::set_allocated_end(::environmentdata::Position* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:environmentdata.StartStopPoints.end)
}

// -------------------------------------------------------------------

// RoutePoints

// repeated .environmentdata.Position pos = 1;
inline int RoutePoints::_internal_pos_size() const {
  return _impl_.pos_.size();
}
inline int RoutePoints::pos_size() const {
  return _internal_pos_size();
}
inline void RoutePoints::clear_pos() {
  _internal_mutable_pos()->Clear();
}
inline ::environmentdata::Position* RoutePoints::mutable_pos(int index) {
  // @@protoc_insertion_point(field_mutable:environmentdata.RoutePoints.pos)
  return _internal_mutable_pos()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Position >*
RoutePoints::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:environmentdata.RoutePoints.pos)
  return _internal_mutable_pos();
}
inline const ::environmentdata::Position& RoutePoints::_internal_pos(int index) const {
  return _internal_pos().Get(index);
}
inline const ::environmentdata::Position& RoutePoints::pos(int index) const {
  // @@protoc_insertion_point(field_get:environmentdata.RoutePoints.pos)
  return _internal_pos(index);
}
inline ::environmentdata::Position* RoutePoints::_internal_add_pos() {
  return _internal_mutable_pos()->Add();
}
inline ::environmentdata::Position* RoutePoints::add_pos() {
  ::environmentdata::Position* _add = _internal_add_pos();
  // @@protoc_insertion_point(field_add:environmentdata.RoutePoints.pos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::environmentdata::Position >&
RoutePoints::pos() const {
  // @@protoc_insertion_point(field_list:environmentdata.RoutePoints.pos)
  return _internal_pos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Position>&
RoutePoints::_internal_pos() const {
  return _impl_.pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::environmentdata::Position>*
RoutePoints::_internal_mutable_pos() {
  return &_impl_.pos_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace environmentdata


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::environmentdata::DataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::environmentdata::DataType>() {
  return ::environmentdata::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_env_5fservice_2eproto_2epb_2eh
